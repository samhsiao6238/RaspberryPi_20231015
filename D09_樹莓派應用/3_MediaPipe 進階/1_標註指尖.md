# 進階應用

## 標註指尖

1. 標註四指指尖，程式碼中的特徵索引 `8, 12, 16, 20` 就是手指指尖的標記。

    ![](images/img_01.png)

<br>

2. 在這個部分最重要的是取得影像中四個關鍵索引的動態座標，範例中透過動態座標繪製一個圓形來標註指尖位置。

    ```python
    cx, cy = int(lm.x * w), int(lm.y * h)
    ```

<br>

3. 完整程式碼。

    ```python
    import cv2
    import mediapipe as mp

    # 初始化 MediaPipe 解決方案中手部追踪的模組
    mp_hands = mp.solutions.hands
    # 初始化繪圖工具，負責繪圖的模組
    mp_drawing = mp.solutions.drawing_utils
    # 創建了一個 Hands 類的實例，負責處理手部追踪的功能。
    hands = mp_hands.Hands()

    # 開啟鏡頭
    cap = cv2.VideoCapture(0)

    while cap.isOpened():
        success, image = cap.read()
        if not success:
            continue

        # 處理影像並進行手部偵測
        image = cv2.cvtColor(cv2.flip(image, 1), cv2.COLOR_BGR2RGB)
        results = hands.process(image)

        # 將影像顏色空間轉回 BGR 以顯示
        image = cv2.cvtColor(image, cv2.COLOR_RGB2BGR)

        # 繪製手部標記
        if results.multi_hand_landmarks:
            for hand_landmarks in results.multi_hand_landmarks:
                mp_drawing.draw_landmarks(
                    image, hand_landmarks, mp_hands.HAND_CONNECTIONS
                )

                # 獲取指尖位置並模擬按壓效果
                for id, lm in enumerate(hand_landmarks.landmark):
                    # 8, 12, 16, 20 是手指指尖的標記
                    if id in [8, 12, 16, 20]:
                        # 取得影像的高 height、寬width、通道 channel
                        h, w, c = image.shape
                        # lm.x 及 lm.y 會取得 landmark 相對於圖像的水平與垂直位置
                        # 然後乘上寬高就等同於取得像素座標
                        cx, cy = int(lm.x * w), int(lm.y * h)
                        # 透過像素座標作為原心畫出圓形
                        cv2.circle(image, (cx, cy), 15, (255, 0, 255), cv2.FILLED)

        # 顯示影像
        cv2.imshow('MediaPipe Hands with OpenCV', image)

        # 按下 q 或 ESC 鍵退出
        if cv2.waitKey(5) & 0xFF == ord('q') or cv2.waitKey(5) == 27:
            break

    cap.release()
    cv2.destroyAllWindows()

    ```

<br>

## 遮蔽影像

1. 透過 `np.zeros()` 製作全黑背景，取代人物影像，觀察手指特徵。

    ```python
    np.zeros((h, w, c), dtype=np.uint8)
    ```

<br>

2. 完整程式碼。

    ```python
    import cv2
    import mediapipe as mp
    import numpy as np

    # 初始化 MediaPipe 手部模型
    mp_hands = mp.solutions.hands
    mp_drawing = mp.solutions.drawing_utils
    hands = mp_hands.Hands()

    # 開啟攝像頭
    cap = cv2.VideoCapture(0)
    # 假如處在開啟狀態
    while cap.isOpened():
        # 讀取影像，回傳兩個值
        success, image = cap.read()
        # 用第一個回傳值判讀是否成功取得影像
        if not success:
            # 假如失敗，結束這一輪迴圈，重新開始
            continue

        # 成功取得影像，透過 .shape 取得高、寬、通道
        h, w, c = image.shape

        # 透過 np.zeros 創建一個與影像相同大小且初始值為 0 的數據資料
        # np.uint8 取值範圍為 0~255
        # 這個程式碼會建立一個全黑背景需要的數據
        background = np.zeros((h, w, c), dtype=np.uint8)

        # 轉會圖像格式並進行水平翻轉
        image = cv2.cvtColor(cv2.flip(image, 1), cv2.COLOR_BGR2RGB)
        # 進行手部偵測
        results = hands.process(image)

        # 假如有取得特徵資料
        if results.multi_hand_landmarks:
            # 遍歷特徵
            for hand_landmarks in results.multi_hand_landmarks:
                # 繪圖：黑色背景、特徵索引、使用預設的連結樣式
                mp_drawing.draw_landmarks(
                    background, hand_landmarks, mp_hands.HAND_CONNECTIONS
                )

        # 顯示影像，背景是全黑的
        cv2.imshow('MediaPipe Hands Grid', background)

        # 按下 q 或 ESC 键退出
        if cv2.waitKey(5) & 0xFF == ord('q') or cv2.waitKey(5) == 27:
            break

    # 釋放資源
    cap.release()
    # 關閉視窗
    cv2.destroyAllWindows()

    ```
   

## 相片按壓效果

1. 透過遍歷相片每個像素進行位置重設達到扭曲效果。

    ![](images/img_02.png)

<br>

2. 完整程式碼。

    ```python
    import cv2
    import numpy as np


    # 設定期望的影像大小
    DESIRED_WIDTH = 800
    DESIRED_HEIGHT = 600


    # 定義一個函數來調整影像尺寸
    def resize_image(image, width=DESIRED_WIDTH, height=DESIRED_HEIGHT):
        # 獲取影像當前的高度和寬度
        h, w = image.shape[:2]
        # 計算縮放比例
        scale = min(width / w, height / h)
        # 獲得新的影像尺寸
        new_size = (int(w * scale), int(h * scale))
        # 調整影像大小
        resized_image = cv2.resize(image, new_size, interpolation=cv2.INTER_AREA)
        return resized_image


    # 定義一個函數來應用波浪效果
    def apply_wave_effect(
        image, center=None, intensity=40, radius=100, frequency=5, transition_width=40
    ):
        # 獲取影像的高度和寬度
        h, w = image.shape[:2]
        # 如果未指定中心，則使用影像的中心點
        if center is None:
            center = (w // 2, h // 2)

        # 產生一組座標網格
        xx, yy = np.meshgrid(np.arange(w), np.arange(h))

        # 計算每個點距離中心的距離
        distances = np.sqrt((xx - center[0]) ** 2 + (yy - center[1]) ** 2)

        # 在指定半徑內應用波浪效果，並在邊緣處進行平滑過渡
        transition = np.clip((radius - distances) / transition_width, 0, 1)
        wave_effect = (
            np.cos(distances / radius * frequency * np.pi) * intensity * transition
        )

        # 通過改變 yy 座標來應用波浪效果
        yy_shifted = np.clip(yy - wave_effect.astype(np.int32), 0, h - 1)

        # 通過重新映射像素來創建扭曲的影像
        distorted_image = cv2.remap(
            image,
            xx.astype(np.float32),
            yy_shifted.astype(np.float32),
            interpolation=cv2.INTER_LINEAR,
        )
        # 返回扭曲後的影像
        return distorted_image


    # 加載影像
    image_path = "image01.jpeg"
    image = cv2.imread(image_path)

    # 檢查並調整影像尺寸
    if image.shape[0] > DESIRED_HEIGHT or image.shape[1] > DESIRED_WIDTH:
        image = resize_image(image)

    # 應用波浪效果
    distorted_image = apply_wave_effect(image)

    # 儲存扭曲後的影像
    output_path = "distorted_image.png"
    cv2.imwrite(output_path, distorted_image)

    # 顯示影像
    cv2.imshow("Original", image)
    cv2.imshow("Wave Effect", distorted_image)
    # 等待按鍵後關閉視窗
    cv2.waitKey(0)
    # 銷毀所有視窗
    cv2.destroyAllWindows()

    ```

<br>

---

_END_